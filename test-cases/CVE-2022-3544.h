// this is the header file for CVE-2022-3544

#include <malloc.h>
#include <stdbool.h>

typedef int gfp_t;
int GFP_KERNEL = 0;
int ENOMEM = 1;
int EINVAL = 1;

struct pid;
struct pid *find_get_pid(int nr) { return 0; };

struct list_head {
  struct list_head *next, *prev;
};

/**
 * struct damon_region - Represents a monitoring target region.
 * @ar:			The address range of the region.
 * @sampling_addr:	Address of the sample for the next access check.
 * @nr_accesses:	Access frequency of this region.
 * @list:		List head for siblings.
 * @age:		Age of this region.
 *
 * @age is initially zero, increased for each aggregation interval, and reset
 * to zero again if the access frequency is significantly changed.  If two
 * regions are merged into a new region, both @nr_accesses and @age of the new
 * region are set as region size-weighted average of those of the two regions.
 */
struct damon_region {
  unsigned long sampling_addr;
  unsigned int nr_accesses;
  struct list_head list;

  unsigned int age;
  /* private: Internal value for age calculation. */
  unsigned int last_nr_accesses;
};

// from linux/damon.h (actual definition of struct)
/**
 * struct damon_target - Represents a monitoring target.
 * @pid:		The PID of the virtual address space to monitor.
 * @nr_regions:		Number of monitoring target regions of this target.
 * @regions_list:	Head of the monitoring target regions of this target.
 * @list:		List head for siblings.
 *
 * Each monitoring context could have multiple targets.  For example, a context
 * for virtual memory address spaces could have multiple target processes.  The
 * @pid should be set for appropriate &struct damon_operations including the
 * virtual address spaces monitoring operations.
 */
struct damon_target {
  struct pid *pid;
  unsigned int nr_regions;
  struct list_head regions_list;
  struct list_head list;
};

/**
 * struct damon_ctx - Represents a context for each monitoring.  This is the
 * main interface that allows users to set the attributes and get the results
 * of the monitoring.
 *
 * @attrs:		Monitoring attributes for accuracy/overhead control.
 * @kdamond:		Kernel thread who does the monitoring.
 * @kdamond_lock:	Mutex for the synchronizations with @kdamond.
 *
 * For each monitoring context, one kernel thread for the monitoring is
 * created.  The pointer to the thread is stored in @kdamond.
 *
 * Once started, the monitoring thread runs until explicitly required to be
 * terminated or every monitoring target is invalid.  The validity of the
 * targets is checked via the &damon_operations.target_valid of @ops.  The
 * termination can also be explicitly requested by calling damon_stop().
 * The thread sets @kdamond to NULL when it terminates. Therefore, users can
 * know whether the monitoring is ongoing or terminated by reading @kdamond.
 * Reads and writes to @kdamond from outside of the monitoring thread must
 * be protected by @kdamond_lock.
 *
 * Note that the monitoring thread protects only @kdamond via @kdamond_lock.
 * Accesses to other fields must be protected by themselves.
 *
 * @ops:	Set of monitoring operations for given use cases.
 * @callback:	Set of callbacks for monitoring events notifications.
 *
 * @adaptive_targets:	Head of monitoring targets (&damon_target) list.
 * @schemes:		Head of schemes (&damos) list.
 */
struct damon_ctx {
  struct list_head adaptive_targets;
  struct list_head schemes;
};

/**
 * struct damos - Represents a Data Access Monitoring-based Operation Scheme.
 * @pattern:		Access pattern of target regions.
 * @action:		&damo_action to be applied to the target regions.
 * @quota:		Control the aggressiveness of this scheme.
 * @wmarks:		Watermarks for automated (in)activation of this scheme.
 * @filters:		Additional set of &struct damos_filter for &action.
 * @stat:		Statistics of this scheme.
 * @list:		List head for siblings.
 *
 * For each aggregation interval, DAMON finds regions which fit in the
 * &pattern and applies &action to those. To avoid consuming too much
 * CPU time or IO resources for the &action, &quota is used.
 *
 * To do the work only when needed, schemes can be activated for specific
 * system situations using &wmarks.  If all schemes that registered to the
 * monitoring context are inactive, DAMON stops monitoring either, and just
 * repeatedly checks the watermarks.
 *
 * If all schemes that registered to a &struct damon_ctx are inactive, DAMON
 * stops monitoring and just repeatedly checks the watermarks.
 *
 * Before applying the &action to a memory region, &struct damon_operations
 * implementation could check pages of the region and skip &action to respect
 * &filters
 *
 * After applying the &action to each region, &stat_count and &stat_sz is
 * updated to reflect the number of regions and total size of regions that the
 * &action is applied.
 */
struct damos {
  struct list_head filters;
  struct list_head list;
};

/**
 * struct damon_operations - Monitoring operations for given use cases.
 *
 * @id:				Identifier of this operations set.
 * @init:			Initialize operations-related data structures.
 * @update:			Update operations-related data structures.
 * @prepare_access_checks:	Prepare next access check of target regions.
 * @check_accesses:		Check the accesses to target regions.
 * @reset_aggregated:		Reset aggregated accesses monitoring results.
 * @get_scheme_score:		Get the score of a region for a scheme.
 * @apply_scheme:		Apply a DAMON-based operation scheme.
 * @target_valid:		Determine if the target is valid.
 * @cleanup:			Clean up the context.
 *
 * DAMON can be extended for various address spaces and usages.  For this,
 * users should register the low level operations for their target address
 * space and usecase via the &damon_ctx.ops.  Then, the monitoring thread
 * (&damon_ctx.kdamond) calls @init and @prepare_access_checks before starting
 * the monitoring, @update after each &damon_attrs.ops_update_interval, and
 * @check_accesses, @target_valid and @prepare_access_checks after each
 * &damon_attrs.sample_interval.  Finally, @reset_aggregated is called after
 * each &damon_attrs.aggr_interval.
 *
 * Each &struct damon_operations instance having valid @id can be registered
 * via damon_register_ops() and selected by damon_select_ops() later.
 * @init should initialize operations-related data structures.  For example,
 * this could be used to construct proper monitoring target regions and link
 * those to @damon_ctx.adaptive_targets.
 * @update should update the operations-related data structures.  For example,
 * this could be used to update monitoring target regions for current status.
 * @prepare_access_checks should manipulate the monitoring regions to be
 * prepared for the next access check.
 * @check_accesses should check the accesses to each region that made after the
 * last preparation and update the number of observed accesses of each region.
 * It should also return max number of observed accesses that made as a result
 * of its update.  The value will be used for regions adjustment threshold.
 * @reset_aggregated should reset the access monitoring results that aggregated
 * by @check_accesses.
 * @get_scheme_score should return the priority score of a region for a scheme
 * as an integer in [0, &DAMOS_MAX_SCORE].
 * @apply_scheme is called from @kdamond when a region for user provided
 * DAMON-based operation scheme is found.  It should apply the scheme's action
 * to the region and return bytes of the region that the action is successfully
 * applied.
 * @target_valid should check whether the target is still valid for the
 * monitoring.
 * @cleanup is called from @kdamond just before its termination.
 */
struct damon_operations {
  // enum damon_ops_id id;
  void (*init)(struct damon_ctx *context);
  void (*update)(struct damon_ctx *context);
  void (*prepare_access_checks)(struct damon_ctx *context);
  unsigned int (*check_accesses)(struct damon_ctx *context);
  void (*reset_aggregated)(struct damon_ctx *context);
  int (*get_scheme_score)(struct damon_ctx *context, struct damon_target *t,
                          struct damon_region *r, struct damos *scheme);
  unsigned long (*apply_scheme)(struct damon_ctx *context,
                                struct damon_target *t, struct damon_region *r,
                                struct damos *scheme);
  bool (*target_valid)(struct damon_target *t);
  void (*cleanup)(struct damon_ctx *context);
};

struct damon_sysfs_regions {
  int nr;
};

struct damon_sysfs_target {
  struct damon_sysfs_regions *regions;
  int pid;
};

static inline void INIT_LIST_HEAD(struct list_head *list);

void *kmalloc(size_t size, gfp_t gfp);

void kfree(void *p);

// from mm/damon/core.c (method that returns struct)
/*
 * Construct a damon_target struct
 *
 * Returns the pointer to the new struct if success, or NULL otherwise
 */
struct damon_target *damon_new_target(void) {
  struct damon_target *t;

  t = kmalloc(sizeof(*t), GFP_KERNEL);
  if (!t)
    return NULL;

  t->pid = NULL;
  t->nr_regions = 0;
  INIT_LIST_HEAD(&t->regions_list);
  INIT_LIST_HEAD(&t->list);

  return t;
}

int damon_target_has_pid(struct damon_ctx *ctx);

static int damon_sysfs_set_regions(struct damon_target *t,
                                   struct damon_sysfs_regions *sysfs_regions);

int list_add_tail(struct list_head *a, struct list_head *b);

int damon_for_each_region_safe(struct damon_region *a, struct damon_region *b,
                               struct damon_target *c);

int damon_free_region(struct damon_region *x);

int list_del(struct list_head *);

int put_pid(struct pid *);

void damon_add_target(struct damon_ctx *ctx,
                      struct damon_target *t); // found in mm/damon/core.c

void damon_for_each_target_safe(struct damon_target *t,
                                struct damon_target *next,
                                struct damon_ctx *ctx);

static void damon_del_target(struct damon_target *t);

void damon_free_target(struct damon_target *t);

void damon_destroy_target(struct damon_target *t);

static void damon_sysfs_destroy_targets(struct damon_ctx *ctx);

static int
damon_sysfs_add_target_does_error(struct damon_sysfs_target *sys_target,
                                  struct damon_ctx *ctx);

static int
damon_sysfs_add_target_does_not_error(struct damon_sysfs_target *sys_target,
                                      struct damon_ctx *ctx);
