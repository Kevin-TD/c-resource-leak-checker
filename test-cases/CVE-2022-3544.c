#include "CVE-2022-3544.h"

void main() {
  struct damon_sysfs_target *st;
  struct damon_ctx *ctx;
  damon_sysfs_add_target_does_error(st, ctx);
  damon_sysfs_add_target_does_not_error(st, ctx);
}

static int
damon_sysfs_add_target_does_error(struct damon_sysfs_target *sys_target,
                                  struct damon_ctx *ctx) {
  struct damon_target *t = damon_new_target();
  int err = -EINVAL;

  if (!t)
    return -ENOMEM;
  // here add damon_add_target(ctx, t);
  if (damon_target_has_pid(ctx)) {
    t->pid = find_get_pid(sys_target->pid);
    if (!t->pid)
      goto destroy_targets_out;
  }
  damon_add_target(ctx, t); // remove this
  err = damon_sysfs_set_regions(t, sys_target->regions);
  if (err)
    goto destroy_targets_out;
  return 0;

destroy_targets_out:
  damon_sysfs_destroy_targets(ctx);
  return err;
}

static int
damon_sysfs_add_target_does_not_error(struct damon_sysfs_target *sys_target,
                                      struct damon_ctx *ctx) {
  struct damon_target *t = damon_new_target();
  int err = -EINVAL;

  if (!t)
    return -ENOMEM;
  damon_add_target(ctx, t);
  if (damon_target_has_pid(ctx)) {
    t->pid = find_get_pid(sys_target->pid);
    if (!t->pid)
      goto destroy_targets_out;
  }
  err = damon_sysfs_set_regions(t, sys_target->regions);
  if (err)
    goto destroy_targets_out;
  return 0;

destroy_targets_out:
  damon_sysfs_destroy_targets(ctx);
  return err;
}

static void damon_sysfs_destroy_targets(struct damon_ctx *ctx) {
  struct damon_target *t, *next;
  bool has_pid = damon_target_has_pid(ctx);

  damon_for_each_target_safe(t, next, ctx);
  {
    if (has_pid)
      put_pid(t->pid);
    damon_destroy_target(t);
  }
}

void damon_destroy_target(struct damon_target *t) {
  damon_del_target(t);
  damon_free_target(t);
}

static void damon_del_target(struct damon_target *t) { list_del(&t->list); }

void damon_free_target(struct damon_target *t) // deallocation site?
{
  struct damon_region *r, *next;

  damon_for_each_region_safe(r, next, t);
  damon_free_region(r);
  kfree(t);
}

void *kmalloc(size_t size, gfp_t gfp) {
  void *ret;

  ret = malloc(size);

  return ret;
}

void kfree(void *p) {
  if (!p)
    return;

  free(p);
}

int damon_target_has_pid(struct damon_ctx *ctx) { return 0; }

static int damon_sysfs_set_regions(struct damon_target *t,
                                   struct damon_sysfs_regions *sysfs_regions) {
  return 0;
}

int list_add_tail(struct list_head *a, struct list_head *b) { return 0; }

int damon_for_each_region_safe(struct damon_region *a, struct damon_region *b,
                               struct damon_target *c) {
  return 0;
}

int damon_free_region(struct damon_region *x) { return 0; }

int list_del(struct list_head *) { return 0; }

int put_pid(struct pid *) { return 0; }

void damon_add_target(
    struct damon_ctx *ctx,
    struct damon_target *t) // found in mm/damon/core.c (mm = memory management)
{
  list_add_tail(&t->list, &ctx->adaptive_targets);
}

/** found in list.h header file (linux/scripts/mod/list.h)
 * INIT_LIST_HEAD - Initialize a list_head structure
 * @list: list_head structure to be initialized.
 *
 * Initializes the list_head to point to itself.  If it is a list header,
 * the result is an empty list.
 */
static inline void INIT_LIST_HEAD(struct list_head *list) {
  list->next = list;
  list->prev = list;
}

void damon_for_each_target_safe(struct damon_target *t,
                                struct damon_target *next,
                                struct damon_ctx *ctx) {
  int x = 0;
};